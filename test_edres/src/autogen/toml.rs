# [allow (non_camel_case_types)] # [derive (Debug , serde :: Serialize , serde :: Deserialize)] pub struct Struct { pub number : i64 , pub text : std :: borrow :: Cow < 'static , str > , pub nested : Struct__nested , } # [allow (non_camel_case_types)] # [derive (Debug , serde :: Serialize , serde :: Deserialize)] pub struct Struct__nested { pub array : std :: borrow :: Cow < 'static , [i64] > , } impl Struct { pub const SOURCE_PATH : & 'static str = "data/toml/struct.toml" ; pub const DATA : Struct = Struct { number : 100i64 , text : std :: borrow :: Cow :: Borrowed ("toml") , nested : Struct__nested { array : std :: borrow :: Cow :: Borrowed (& [1i64 , 2i64 , 3i64 ,]) , } , } ; }
# [derive (Debug , Clone , Copy , PartialEq , Eq , Hash , serde :: Serialize , serde :: Deserialize)] pub enum Enum { Variant1 , Variant2 , } impl Enum { pub const SOURCE_PATH : & 'static str = "data/toml/map.toml" ; pub const ALL : & 'static [Self] = & [Self :: Variant1 , Self :: Variant2 ,] ; pub const VALUES : & 'static [Enum__Value] = & [Enum__Value { value : 1i64 , } , Enum__Value { value : 2i64 , } ,] ; pub const fn get (self) -> & 'static Enum__Value { & Self :: VALUES [self as usize] } } impl Default for Enum { fn default () -> Self { Self :: Variant1 } } impl std :: fmt :: Display for Enum { fn fmt (& self , f : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { < Self as std :: fmt :: Debug > :: fmt (self , f) } } impl std :: str :: FromStr for Enum { type Err = () ; fn from_str (s : & str) -> std :: result :: Result < Self , Self :: Err > { Ok (match s { "Variant1" => Self :: Variant1 , "Variant2" => Self :: Variant2 , _ => return Err (()) }) } } # [allow (non_camel_case_types)] # [derive (Debug , serde :: Serialize , serde :: Deserialize)] pub struct Enum__Value { pub value : i64 , }
# [allow (non_camel_case_types)] # [derive (Debug , serde :: Serialize , serde :: Deserialize)] pub struct VStruct { pub value : i64 , } pub const DATA : & [VStruct] = & [VStruct { value : 1i64 , } , VStruct { value : 2i64 , } ,] ;
# [derive (Debug , Clone , Copy , PartialEq , Eq , Hash , serde :: Serialize , serde :: Deserialize)] pub enum FileEnum { FileA , FileB , } impl FileEnum { pub const FILE_PATHS : & 'static [& 'static str] = & ["data/toml/files/file_a.toml" , "data/toml/files/file_b.toml" ,] ; pub const fn path (self) -> & 'static str { Self :: FILE_PATHS [self as usize] } pub const SOURCE_PATH : & 'static str = "data/toml/files" ; pub const ALL : & 'static [Self] = & [Self :: FileA , Self :: FileB ,] ; pub const VALUES : & 'static [FileEnum__Value] = & [FileEnum__Value { name : std :: borrow :: Cow :: Borrowed ("file_a") , } , FileEnum__Value { name : std :: borrow :: Cow :: Borrowed ("file_b") , } ,] ; pub const fn get (self) -> & 'static FileEnum__Value { & Self :: VALUES [self as usize] } } impl Default for FileEnum { fn default () -> Self { Self :: FileA } } impl std :: fmt :: Display for FileEnum { fn fmt (& self , f : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { < Self as std :: fmt :: Debug > :: fmt (self , f) } } impl std :: str :: FromStr for FileEnum { type Err = () ; fn from_str (s : & str) -> std :: result :: Result < Self , Self :: Err > { Ok (match s { "FileA" => Self :: FileA , "FileB" => Self :: FileB , _ => return Err (()) }) } } # [allow (non_camel_case_types)] # [derive (Debug , serde :: Serialize , serde :: Deserialize)] pub struct FileEnum__Value { pub name : std :: borrow :: Cow < 'static , str > , }
# [allow (non_camel_case_types)] # [derive (Debug , serde :: Serialize , serde :: Deserialize)] pub struct FileStruct { pub name : std :: borrow :: Cow < 'static , str > , } pub const FILE_VALUES : & [FileStruct] = & [FileStruct { name : std :: borrow :: Cow :: Borrowed ("file_a") , } , FileStruct { name : std :: borrow :: Cow :: Borrowed ("file_b") , } ,] ;
